\section{Hardware und Betriebssystem [Leopold Mistelberger]}

\subsection{Raspberry Pi mit Ubuntu [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{Beschreibung und Rolle}
Der Raspberry Pi 5 ist ein kleiner, kompakter Computer, der als zentrales Gehirn eines oder mehrerer umliegende Baustellencontainer dient. Er übernimmt die Erfassung sämtlicher Sensordaten, die Steuerung der Aktoren und die Kommunikation mit der Datenbank sowie dem Proxmox-Server im Unternehmen.


\subsection{Technische Eigenschaften}
\begin{itemize}
    \item Leistungsfähiger Prozessor 
    \item 16 Gigabyte Arbeitsspeicher
    \item Netzwerkanschluss
    \item 4x USB-Anschlüsse
    \item GPIO-Pins
    \item Kompakt
    \item Langlebig
    \item Energieeffizient
    \item Kompatibel mit Ubuntu
\end{itemize}

\subsection{Begründung der Wahl}
Der Raspberry Pi war für CESC die perfekte Wahl, da er alle unsere technischen Voraussetzungen erfüllt. Dazu zählen ein USB-Anschluss für den Zigbee-Dongle, ein Netzwerkanschluss für die Kommunikation mit Servern und der Datenbank sowie ein leistungsstarker Prozessor für die Ausführung unserer Programme. Ubuntu wurde als Betriebssystem gewählt, um eine bessere Wartbarkeit und Zuverlässigkeit aller eingesetzten Softwaredienste zu gewährleisten. Der Raspberry Pi ermöglicht somit eine zuverlässige Steuerung der Baustellencontainer.




\subsection{Proxmox [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{pics/proxmox_logo.png}
    \caption{Proxmox Virtual Environment Logo}
    \label{fig:proxmoxlogo}
\end{figure}

Proxmox Virtual Environment (Proxmox VE) ist eine Plattform zur Servervirtualisierung, die Open Source ist. 
Sie erlaubt den Betrieb mehrerer virtueller Systeme auf einer einzigen physischen Hardware und findet häufig Anwendung in Unternehmensumgebungen. 


Die Verwaltung wird zentral über eine webbasierte Benutzeroberfläche durchgeführt. 
Weitere Details finden Sie auf Proxmox offizieller Website (\url{https://www.proxmox.com}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{pics/proxmox_architecture.png}
    \caption{Architektur von Proxmox Virtual Environment}
    \label{fig:proxmoxarchitecture}
\end{figure}

Proxmox läuft auf einem Linux-Hostsystem und verwendet verschiedene Virtualisierungstechnologien. Proxmox fügt zwischen der Hardware und den Anwendungen eine Virtualisierungsschicht ein. Diese dient dazu, Systeme, die auf derselben Hardware laufen, voneinander zu trennen.

Virtuelle Maschinen (VMs) verhalten sich dabei jeweils wie ein eigener Computer mit einem eigenen Betriebssystem. Dadurch sind sie vollständig voneinander getrennt. CPU, Arbeitsspeicher und Speicherplatz werden im Vorhinein fest zugewiesen. Eine VM ist somit vollständig von anderen Systemen isoliert.

Zusätzlich unterstützt Proxmox Container auf Basis von Linux Containers (LXC). Container sind im Vergleich zu VMs leichter und schneller, da sie sich den Linux-Kernel des Servers teilen und arbeiten dadurch deutlich effizienter. Dadurch benötigen sie wenige Ressourcen und eignen sich sehr für den Betrieb Dienste oder Anwedungen.

Die Vorteile von Proxmox liegen unter anderem darin, dass keine Lizenzkosten anfallen, da Proxmox kostenlos verfügbar ist. Dadurch können die Betriebskosten eines Unternehmens gesenkt werden, insbesondere da Virtualisierungslösungen für virtuelle Maschinen zunehmend kostenintensiver werden. Zudem ermöglicht Proxmox eine effizientere Nutzung der vorhandenen Hardware, während die Systeme sauber voneinander getrennt bleiben. Durch das webbasierte Interface erhält der Benutzer eine gute Übersicht, da alle Systeme zentral verwaltet werden können.


\ref{fig:proxmoxarchitecture} dargestellt.



\section{Kommunikation und Automatisierung [Leopold Mistelberger]}
\subsection{Zigbee [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{MQTT [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}



\subsubsection{Beschreibung}
MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Nachrichtenprotokoll, das nach dem sogenannten \textit{Publish-Subscribe-Prinzip} arbeitet \cite{mqtt_org}. Dieses Protokoll wurde speziell für die Übertragung von Daten mit geringer Bandbreite oder instabiler Verbindung entwickelt. Es arbeitet ereignisbasiert und eignet sich besonders für Projekte, bei denen viele Geräte regelmäßig kleine Datenmengen wie Temperatur oder Luftfeuchtigkeit senden, wie beispielsweise in CESC.

\subsubsection{Komponenten und Funktionsweise}
Bei MQTT gibt es drei zentrale Komponenten, die nach dem Pub-Sub-Prinzip arbeiten:

\begin{itemize}
    \item \textbf{Publisher:} Ein Gerät oder Programm, das bestimmte Daten an den Broker sendet. In den meisten Fällen handelt es sich hierbei um einen Sensor.
    \item \textbf{Broker:} Meist ein zentraler Server, der alle Nachrichten empfängt und an die richtigen Empfänger weiterleitet.
    \item \textbf{Subscriber:} Ein Gerät oder Programm, das bestimmte Daten abonniert und diese empfängt.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/mqtt_pub_sub.png} 
    \caption{MQTT-Architektur: Publisher, Broker, Subscriber (Quelle: \url{https://mqtt.org/assets/img/mqtt-publish-subscribe.png}, Lizenz: CC0)}
    \label{fig:mqtt_architektur}
    
\end{figure}

Die Daten werden in sogenannten \textit{Topics} organisiert. Ein Publisher sendet Nachrichten an ein bestimmtes Topic, während Subscriber dieses Topic abonnieren. Der Broker übernimmt die Verteilung der Nachrichten, ohne dass sich Sender und Empfänger direkt kennen müssen.

\subsubsection{Beispielhafte Nutzung}
Um Daten zu empfangen, muss ein Subscriber ein bestimmtes Topic abonnieren. Beispielsweise möchte man die Raumtemperatur eines Containers auslesen. Dazu wird ein Subscriber auf das entsprechende Topic gesetzt:

\begin{lstlisting}[language=bash, caption={Subscriber für Raumtemperatur des Containers 147}]
mosquitto_sub -h <Broker-IP> -t "container/147/raum1/temperatur"
\end{lstlisting}

Neben dem Empfangen von Daten kann man auch Aktoren steuern, wie zum Beispiel die Heizung des Containers. Um diese einzuschalten, verwendet man den folgenden Publisher-Befehl:

\begin{lstlisting}[language=bash, caption={Heizung des Containers 147 einschalten}]
mosquitto_pub -h <Broker-IP> -t "container/147/raum1/heizung" -m "ON"
\end{lstlisting}





\subsubsection{Vorteile von MQTT}
MQTT bietet mehrere Vorteile gegenüber klassischen Kommunikationsprotokollen:

\begin{itemize}
    \item Geringer Netzwerk- und Ressourcenverbrauch
    \item Zuverlässige Datenübertragung auch bei instabilen Verbindungen
    \item Klare Trennung von Sendern und Empfängern
    \item Hohe Skalierbarkeit bei vielen beteiligten Geräten
    \item Besonders geeignet für IoT- und Sensornetzwerke
\end{itemize}


\subsection{Home Assistant [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\section{Container- und Laufzeitumgebung [Leopold Mistelberger]}
\subsection{Docker [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{GitHub Container Registry (ghcr.io) [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\section{Server- und Infrastrukturtechnologien [Elias Mahr]}
\setauthor{Elias Mahr}


\section{Reverse-Proxy [Elias Mahr]}
\setauthor{Elias Mahr}
Ein Reverse-Proxy steht zwischen dem Webserver und dem Internet. Im Grunde fungiert es wie ein Türsteher für den Server. Anfragen werden von außen entgegengenommen und zum richtigen Dienst weitergeleitet(Frontend, Backend, Keycloak,...). Dadurch werden die echten Adressen verschleiert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{pics/ReverseProxy.png}
    \caption{Reverse-Proxy (Quelle: \url{https://commons.wikimedia.org/wiki/File:Reverse_proxy_h2g2bob.svg}, Lizenz: CC0)}
    \label{fig:ReverseProxy}
\end{figure}

\subsection{Nutzen in der Diplomarbeit}
Es gibt drei Hauptgründe, weshalb ein Reverse-Proxy eingebaut werden musste.
\begin{itemize}
\item \underline{Keycloaks https Redirects:}
Keycloak verwendet moderne Standards wie OpenID Connect. Diese Standards setzen auch eine HTTPs Redirect URL voraus. Https setzt im Gegensatz zu http die nötigen Sicherheitsstandards, um zum Beispiel Man-in-the-Middle-Angriffe zu verhindern.
\item \underline{Port Chaos:}
Mit vielen verschiedenen Ports, wie 80 für das Frontend, 8080 für Keycloak und 5000 für das Backend wäre alles sehr unübersichtlich. Der User müsste sich 3 URLs merken.
\item \underline{Sicherheit:}
Zur Reduzierung der Angriffsfläche sollten nur zwingend notwendige Ports öffentlich erreichbar sein. Jeder zusätzlich exponierte Dienst erhöht das Risiko potenzieller Angriffe.
Interne Dienste, wie beispielsweise Backend-Services auf Port 5000, sind nicht von außen erreichbar und bleiben dadurch vor direktem Zugriff geschützt. Die Trennung zwischen öffentlich zugänglichen Komponenten und internen Services stellt eine grundlegende Sicherheitsmaßnahme dar.
Auch wenn eine Webapplikation ausschließlich innerhalb des Intranets betrieben wird, ist der Einsatz zusätzlicher Sicherheitsmechanismen sinnvoll. Eine mehrschichtige Sicherheitsstrategie (Defense in Depth) trägt dazu bei, das Gesamtrisiko weiter zu reduzieren.
\end{itemize}


\section{Auswahl der Technologie - Sicherheit(Authentifizierung)}
\setauthor{Elias Mahr}

Die Firma Herbsthofer legt sehr großen Wert auf Sicherheit. Die externe Bedienung von Heizung, Kühlung und Beleuchtung kann, bei unsachgemäßer Nutzung, zu erheblichen Mehrkosten und mitunter auch zu Schäden führen.

\begin{itemize}
\item Mitarbeiterschutz:
Bei voll eingeschalteter Kühlung an kalten Wintertagen kann es zu gesundheitlichen Schäden in Form von Verkühlungen bei Arbeitern/Arbeiterinnen führen, die auch mit einem Ausfall für ein paar Tage enden können und so der Firma Geld kosten.
\item Brandgefahr:
 Unkontrollierte Heizbetriebe auf einer zu hohen Temperaturstufe können im schlimmsten Fall zu Bränden führen und so erheblichen Schaden anrichten und auch Personenschaden mit sich führen.
\item Kosten: 
Strom wird immer teurer. Bei durchgehender Nutzung auch an Tagen, an denen niemand im Container ist, ist erstens der Schaden an der Umwelt durch extreme Ressourcenverschwendung zu beachten. Zudem entstehen für das Unternehmen hohe, vermeidbare Stromkosten.
\end{itemize}

Um dieses Sicherheitsproblem zu lösen gibt es mehrere Ansätze.

\subsection{Selbsterstellter Login Mechanismus}
Eine nicht sichere, aber durchaus mögliche Option wäre eine selbstgeschriebene Login Componente, die Passwort und Nutzer Gehasht in der Datenbank speichert. 
\subsubsection{Vorteile}
Diese Option hätte den Vorteil einerseits sehr geringe Ressourcen zu beanspruchen. Die Componente könnte man auch direkt ins Backend integrieren, dies wäre in unserem Fall, für nur einen Nutzer, nicht sehr zeitaufwändig. Alles könnte direkt nach dem Wunsch der Firma gebaut werden.
\subsubsection{Nachteile}
Die Sicherheit bei einer selbsterstellten Componente ist für Firmen nicht ausreichend. Selbst erstellte Componenten sind möglicherweise dafür nicht geeignet.
Für erfahrene Hacker könnte so ein Login ein leichtes sein um als Admin auf die Webseite zu kommen mit zum Beispiel einem Brute Force Angriff.
Ein weiterer Nachteil ist, dass es sehr kompliziert ist und von einem externen Programmierer gemacht werden müsste, wenn der Login erweitert werden würde.

\subsection{Vorgefertigter Login (Keycloak [Elias Mahr])}

Das Ziel ist immer, so viele vorgefertigte Systeme wie möglich zu verwenden, solange sie den erforderlichen Anforderungen entsprechen. Eines davon ist in diesem Fall Keycloak.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{pics/KeycloakLogo.png}
    \caption{Keycloak Logo}
    \label{fig:KeycloakLogo}
\end{figure}

\subsubsection{Vorteile}
Keycloak ist ein Open Source System, das heißt, es ist öffentlich zugänglich und kostenlos. Diese Software übernimmt die sichere Anmeldung und die Rechteverwaltung für eine Anwendung übernimmt. Die Anwendungen schicken die Anmeldung an Keycloak und müssen das Speichern und das Prüfen von Benutzerkonten nicht mehr selbst erledigen. So kann die Anwendung sich auf das Wesentliche konzentrieren, während Keycloak die Anmeldung und die Rechte im Hintergrund mit Sicherheitsstandards für Unternehmen regelt.
In der grafischen Oberfläche des Systems ist das Erweitern der Funktionen, zum Beispiel das neue Anlegen von Usern oder eine neue Rechtevergabe, auch für Menschen ohne Vorkenntnisse im Programmieren sehr einfach. Sollte sich die Firma entscheiden unsere Webapp zu erweitern ist das sehr von Vorteil, da sie keine eigene Programmierabteilung im Haus hat.
\subsubsection{Nachteile}
Im Vergleich zu einer selbsterstellten Lösung hat Keycloak einen sehr hohen Ressourcenverbrauch, teilweise auch für Funktionen, die in unserer Webapp nicht implementiert sind. Das Erstellen eines Logins mit Keycloak ist sehr zeitintensiv und nimmt mehrere Tage in Anspruch, besonders für Entwickler, die noch nie damit in Berührung gekommen sind.

\section{Cronjob}
\setauthor{Elias Mahr}

Um die Container wirklich voll automatisch ein- und ausschalten zu können, kam für uns nur die Verwendung eines Cronjobs auf dem Server in Frage. Im Unterricht hatten wir bereits davon gehört.
Ein Cron-Daemon ist ein Linux-Programm, das meistens Shell Skripte zeitgesteuert auslöst, sogenannte Cronjobs. 
Somit kann man Aufgaben nach einem Zeitplan immer wiederholend ausführen.

\subsection{Syntax}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{pics/Cronjob.png}
    \caption{Cronjob Syntax}
    \label{fig:CronjobSyntax}
\end{figure}

Jeder Cronjob ist eine Zeile in dem crontab File. Diese Zeile definiert mit der oben gezeigten Syntax, wann und wie oft welches Skript ausgeführt werden soll.
So können auch komplizierte Zeitpläne für die Durchführung der Schaltungen gebaut werden. Mit / können Schritte definiert werden, wie zum Beispiel bei Stunde = /6. Das würde bedeuten, dass das angeführte Skript bzw. Programm jede 6. Stunde ausgeführt wird. 
Mit dem Operator ``-'' können Bereiche definiert werden, z.B. Wochentag = 0-6. Das würde bedeuten, dass das ausgeführte Skript bzw. Programm täglich ausgeführt wird.


\section{Frontend}
\setauthor{Elias Mahr}

\subsection{Use Cases für die Webapp}
\setauthor{Elias Mahr}

\subsubsection{Baustellenübersicht anzeigen}
Als Geschäftsführer der Firma Herbsthofer möchte ich alle derzeitigen Baustellen auf einen Blick sehen, weil ich schnell zwischen verschiedenen Baustellen wechseln möchte.

Akzeptanzkriterien:
\begin{itemize}
    \item Alle Baustellen werden auf einen Blick übersichtlich angezeigt.
    \item Wenn ich eine Baustelle auswähle, sollen in einer Detailansicht alle Container der Baustelle aufgelistet werden.
    \item Es sollte kein Problem sein, eine Baustelle hinzuzufügen oder zu entfernen.
\end{itemize}

\subsubsection{Containerstatus überwachen}
Als Geschäftsführer der Firma Herbsthofer  möchte ich den aktuellen Temperaturstatus aller Container einer Baustelle sehen, weil ich die sinnvolle Schaltung der Heizung kontrollieren muss und darauf achte, dass meine Mitarbeiter nicht beispielsweise im Winter die Türe offen lassen.

Akzeptanzkriterien:
\begin{itemize}
    \item Innen- und Außentemperatur werden in Echtzeit angezeigt.
    \item Luftfeuchtigkeit wird auch klein angezeigt.
\end{itemize}


\subsubsection{Anmeldung}
Als Geschäftsführer der Firma Herbsthofer  möchte ich mich sicher am System anmelden wenn ich gewisse Funktionen nutzen möchte, weil sonnst Mitarbeiter die Funktionen ausnützen und somit Schäden verursachen könnten.

Akzeptanzkriterien:
\begin{itemize}
    \item Zur Anmeldung wird etwas Vorgefertigtes genommen.
    \item Alles sollte auf unternehmerischem Standard sein.
    \item Nach erfolgreicher Anmeldung sollten die Urlaube bearbeitet werden können.
\end{itemize}

\subsubsection{Türzugriffe protokollieren}
Als Geschäftsführer der Firma Herbsthofer  möchte ich alle Türöffnungen sehen, weil ich Einbrüche oder unbefugten Zugriff nachvollziehen muss.

Akzeptanzkriterien:
\begin{itemize}
    \item Die Bewegungen der Türe werden aufgezeichnet und können im Nachhinein eingesehen werden. Es wird unterschieden zwischen Türbewegung in der Arbeitszeit und Türbewegung außerhalb der Arbeitszeit.
    \item Im Frontend gibt es eine Visualisierung dieser Daten.
\end{itemize}

\subsubsection{Sensorverlaufsdaten analysieren}
Als Geschäftsführer der Firma Herbsthofer  möchte ich vergangene Sensordaten visualisiert sehen, weil ich eventuelle Kosten nachvollziehen möchte.

Akzeptanzkriterien:
\begin{itemize}
    \item Daten werden mit einem vorgefertigten Tool, zum Beispiel Grafana oder Plottly, visualisiert.
    \item Es soll auf verschiedene Zeiträume gefiltert werden können.
\end{itemize}

\subsubsection{Sichere Kommunikation gewährleisten}
Als Geschäftsführer der Firma Herbsthofer möchte ich dass alle Verbindungen geschützt sind, weil verhindert werden sollte, dass Hacker an geheime Daten kommen.

Akzeptanzkriterien:
\begin{itemize}
    \item Nginx ist mit Reverse Proxy implementiert und es sind nur wirklich notwendige Ports öffentlich.
    \item Let's Encrypt Zertifikat
\end{itemize}

\subsubsection{Energiekosten reduzieren}
Als Geschäftsführer der Firma Herbsthofer möchte ich Heizung und Kühlung automatisch steuern, weil ich unnötige Energiekosten vermeiden möchte.

Akzeptanzkriterien:
\begin{itemize}
    \item Container werden an Betriebsurlauben nicht beheizt/gekühlt
    \item Container werden an Feiertagen nicht beheizt/gekühlt.
    \item Container werden nur während der Arbeitszeit beheizt/gekühlt.
    \item Dafür wird ein Cronjob am Server benutzt.
\end{itemize}


\subsubsection{Mobiler Zugriff}
Als Geschäftsführer der Firma Herbsthofer   möchte ich die Webapp auf meinem Smartphone nutzen, weil ich für spontanes Nachsehen, auf zum Beispiel einer Baustelle, keinen Laptop/PC zur Verfügung habe

Akzeptanzkriterien:
\begin{itemize}
    \item Die Webapp ist responsive.
    \item Alle Features sind mobil genauso verfügbar.
\end{itemize}

\subsection{Use Case Diagram}
\setauthor{Elias Mahr}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{pics/UseCase2.png}
    \caption{Use Case Diagram}
    \label{fig:UseCase}
\end{figure}


\section{Api}
\setauthor{Elias Mahr}

\section{Backend}
\setauthor{Timon Schmalzer}

\subsection{ASP.NET Core \& C\#}
\setauthor{Timon Schmalzer}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{pics/aspnetcore_logo.png}
    \caption{ASP.NET Core Logo (Quelle: campusMVP GitHub Repository, \url{https://github.com/campusMVP/dotnetCoreLogoPack}, Lizenz: CC BY-SA 4.0)}
    \label{fig:aspnetcorelogo}
\end{figure}

ASP.NET Core ist ein modernes, plattformübergreifendes Framework von Microsoft zur Entwicklung von Webanwendungen und APIs. Es ist die Weiterentwicklung des klassischen ASP.NET Frameworks und wurde von Grund auf neu entwickelt, um performanter, modularer und flexibler zu sein.

\subsubsection{Grundlagen und Eigenschaften}

ASP.NET Core ist ein \textbf{Open-Source Framework}, das auf der .NET-Plattform basiert. Im Gegensatz zu seinem Vorgänger läuft ASP.NET Core nicht nur auf Windows, sondern auch auf \textbf{Linux und macOS}, was es zu einer idealen Wahl für containerisierte Anwendungen macht.

Die wichtigsten Merkmale von ASP.NET Core sind:

\begin{itemize}
    \item \textbf{Hohe Performance:} ASP.NET Core gehört zu den schnellsten Web-Frameworks weltweit und ist besonders bei vielen gleichzeitigen Anfragen sehr effizient.
    \item \textbf{Plattformunabhängigkeit:} Durch die Cross-Platform-Unterstützung kann die Anwendung auf verschiedenen Betriebssystemen entwickelt und deployed werden.
    \item \textbf{Modular aufgebaut:} Das Framework verwendet ein schlankes Kern-System, das nur die wirklich benötigten Komponenten lädt.
    \item \textbf{Dependency Injection:} Ein eingebautes DI-System ermöglicht eine saubere Architektur und bessere Testbarkeit.
    \item \textbf{Cloud-ready:} Perfekt geeignet für Cloud-Deployments und Container-Orchestrierung mit Docker.
\end{itemize}

\subsubsection{C\# als Backend-Sprache}

Die Programmiersprache \textbf{C\#} (C-Sharp) ist eine moderne, objektorientierte Sprache, die speziell für die .NET-Plattform entwickelt wurde. Sie kombiniert die Leistungsfähigkeit von C++ mit der Einfachheit von Java.

Vorteile von C\# für Backend-Entwicklung:

\begin{itemize}
    \item \textbf{Type Safety:} Durch statische Typisierung werden viele Fehler bereits zur Compile-Zeit erkannt, nicht erst zur Laufzeit.
    \item \textbf{Async/Await Pattern:} Native Unterstützung für asynchrone Programmierung, was besonders bei I/O-intensiven Operationen wie Datenbankzugriffen wichtig ist.
    \item \textbf{LINQ (Language Integrated Query):} Ermöglicht das einfache Filtern und Transformieren von Datensammlungen direkt in C\#.
    \item \textbf{Moderne Sprachfeatures:} Pattern Matching, Records, Nullable Reference Types und viele weitere Features, die den Code sauberer und sicherer machen.
    \item \textbf{Große Community:} Als etablierte Enterprise-Sprache gibt es umfangreiche Dokumentation und Community-Support.
\end{itemize}

\subsubsection{RESTful API Architektur}

Das Backend des CESC-Projekts ist als \textbf{REST API} (Representational State Transfer) konzipiert. REST ist ein Architekturstil für verteilte Systeme, der auf HTTP-Methoden basiert:

\begin{itemize}
    \item \textbf{GET:} Daten abrufen (z.B. Container-Informationen, Sensordaten)
    \item \textbf{POST:} Neue Ressourcen erstellen (z.B. neue Kalenderregel)
    \item \textbf{PUT:} Bestehende Ressourcen aktualisieren (z.B. Container-Namen ändern)
    \item \textbf{DELETE:} Ressourcen löschen (z.B. Kalenderregel entfernen)
\end{itemize}

Die API kommuniziert über \textbf{JSON} (JavaScript Object Notation) als Datenformat, da dies sowohl menschen- als auch maschinenlesbar ist und sich perfekt für die Kommunikation zwischen Frontend und Backend eignet.

\subsubsection{Warum ASP.NET Core für CESC?}

Die Wahl von ASP.NET Core für das Backend der CESC-Anwendung basiert auf mehreren Überlegungen:

\begin{itemize}
    \item \textbf{Performance bei IoT-Daten:} Die Anwendung muss in der Lage sein, regelmäßig Sensordaten von mehreren Containern zu verarbeiten. ASP.NET Core bietet hierfür die nötige Performance.
    
    \item \textbf{Docker-Kompatibilität:} Da die gesamte Anwendung containerisiert deployed wird, ist die plattformunabhängige Natur von ASP.NET Core essentiell.
    
    \item \textbf{Enterprise-Standard:} Die Firma Herbsthofer setzt auf bewährte, sichere Technologien. ASP.NET Core wird von Microsoft Enterprise-Support unterstützt.
    
    \item \textbf{Integration mit Keycloak:} Die eingebaute JWT-Authentication in ASP.NET Core vereinfacht die Integration mit dem Keycloak Identity Provider erheblich.
    
    \item \textbf{Zukunftssicherheit:} Microsoft investiert kontinuierlich in .NET und ASP.NET Core. Die aktuell verwendete Version .NET 8.0 hat Long-Term-Support bis November 2026.
    
    \item \textbf{Entwickler-Produktivität:} Durch die starke Typisierung, IntelliSense-Unterstützung und umfangreiche Tooling-Unterstützung in Visual Studio und VS Code können Features schneller und fehlerfreier entwickelt werden.
\end{itemize}

\subsection{Swagger/OpenAPI - API Dokumentation}
\setauthor{Timon Schmalzer}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{pics/Swagger-logo.png}
    \caption{Swagger Logo (Quelle: https://commons.wikimedia.org/wiki/File:Swagger-logo.png, Lizenz: CC BY-SA 4.0)}
    \label{fig:swaggerlogo}
\end{figure}

Swagger ist ein Framework zur Dokumentation und zum Testen von REST APIs. Es generiert automatisch eine interaktive Dokumentation, die alle verfügbaren Endpoints, ihre Parameter und Rückgabewerte übersichtlich darstellt.

\subsubsection{Beschreibung und Zweck}

OpenAPI (früher bekannt als Swagger) ist ein Standard zur Beschreibung von REST APIs. Die Spezifikation definiert, wie eine API strukturiert ist, welche Endpoints existieren und welche Daten sie erwarten und zurückgeben. In ASP.NET Core wird dies durch die \textbf{Swashbuckle.AspNetCore} Bibliothek realisiert.

Die Hauptvorteile von Swagger sind:

\begin{itemize}
    \item \textbf{Automatische Dokumentation:} Die API-Dokumentation wird direkt aus dem Code generiert und ist immer aktuell.
    \item \textbf{Interaktives Testing:} Entwickler können API-Endpoints direkt im Browser testen, ohne zusätzliche Tools wie Postman zu benötigen.
    \item \textbf{Klare Übersicht:} Alle verfügbaren Endpoints, HTTP-Methoden und Datenmodelle werden strukturiert angezeigt.
    \item \textbf{Client-Code-Generierung:} Aus der OpenAPI-Spezifikation können automatisch Client-Bibliotheken für verschiedene Programmiersprachen generiert werden.
\end{itemize}

\subsubsection{Funktionsweise in CESC}

Im CESC-Backend ist Swagger so konfiguriert, dass es nur im \textbf{Development-Modus} verfügbar ist. In der Production-Umgebung ist die Swagger-UI aus Sicherheitsgründen deaktiviert, da sie Details über die API-Struktur preisgibt.

Die Swagger-UI zeigt alle verfügbaren Endpoints übersichtlich gruppiert nach Controllern:

\begin{itemize}
    \item \textbf{CalendarController:} Endpoints zur Verwaltung von Kalenderregeln (GET, POST, DELETE)
    \item \textbf{ContainersController:} Endpoints zum Abrufen und Verwalten von Container-Daten
    \item \textbf{SensorsController:} Endpoints für aktuelle Sensordaten
    \item \textbf{PlugControlController:} Endpoints zur Steuerung von Steckdosen (Heizung, Kühlung, Licht)
    \item \textbf{DoorsController:} Endpoints zum Abrufen des Türstatus
\end{itemize}

\subsubsection{HTTP-Methoden in der Swagger-UI}

Swagger visualisiert die verschiedenen HTTP-Methoden farblich, um sie auf einen Blick unterscheidbar zu machen:

\begin{itemize}
    \item \textbf{GET (Blau):} Daten abrufen, z.B. \texttt{GET /api/containers}
    \item \textbf{POST (Grün):} Neue Ressourcen erstellen, z.B. \texttt{POST /api/calendar/\{containerId\}}
    \item \textbf{PUT (Orange):} Ressourcen aktualisieren
    \item \textbf{DELETE (Rot):} Ressourcen löschen, z.B. \texttt{DELETE /api/calendar/\{containerId\}}
\end{itemize}

\subsubsection{Authentication in Swagger}

Da die CESC-API durch Keycloak geschützt ist, muss auch in Swagger ein JWT-Token für geschützte Endpoints angegeben werden. Swagger bietet hierfür einen \textbf{\glqq Authorize\grqq}-Button, über den ein Bearer-Token eingegeben werden kann.

Nach erfolgreicher Anmeldung bei Keycloak kann das erhaltene JWT-Token in Swagger eingetragen werden. Alle nachfolgenden API-Aufrufe werden dann automatisch mit diesem Token authentifiziert.

\subsubsection{Vorteile für die Entwicklung}

Während der Entwicklungsphase von CESC erwies sich Swagger als äußerst hilfreich:

\begin{itemize}
    \item \textbf{Frontend-Backend-Abstimmung:} Das Frontend-Team konnte die verfügbaren Endpoints und deren Datenstrukturen direkt einsehen, ohne in den Backend-Code schauen zu müssen.
    
    \item \textbf{Schnelles Testing:} Neue Endpoints konnten sofort nach der Implementierung über Swagger getestet werden, bevor sie ins Frontend integriert wurden.
    
    \item \textbf{Fehlerbehebung:} Bei Problemen konnte schnell überprüft werden, ob das Backend korrekte Daten zurückliefert oder ob der Fehler im Frontend liegt.
    
    \item \textbf{Dokumentation für die Firma:} Die Swagger-Dokumentation dient auch als Referenz für zukünftige Entwickler oder Wartungspersonal der Firma Herbsthofer.
\end{itemize}