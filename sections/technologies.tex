\section{Hardware und Betriebssystem [Leopold Mistelberger]}

\subsection{Raspberry Pi mit Ubuntu [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{Beschreibung und Rolle}
Der Raspberry Pi 5 ist ein kleiner, kompakter Computer, der als zentrales Gehirn eines oder mehrerer umliegende Baustellencontainer dient. Er übernimmt die Erfassung sämtlicher Sensordaten, die Steuerung der Aktoren und die Kommunikation mit der Datenbank sowie dem Proxmox-Server im Unternehmen.


\subsection{Technische Eigenschaften}
\begin{itemize}
    \item Leistungsfähiger Prozessor 
    \item 16 Gigabyte Arbeitsspeicher
    \item Netzwerkanschluss
    \item 4x USB-Anschlüsse
    \item GPIO-Pins
    \item Kompakt
    \item Langlebig
    \item Energieeffizient
    \item Kompatibel mit Ubuntu
\end{itemize}

\subsection{Begründung der Wahl}
Der Raspberry Pi war für CESC die perfekte Wahl, da er alle unsere technischen Voraussetzungen erfüllt. Dazu zählen ein USB-Anschluss für den Zigbee-Dongle, ein Netzwerkanschluss für die Kommunikation mit Servern und der Datenbank sowie ein leistungsstarker Prozessor für die Ausführung unserer Programme. Ubuntu wurde als Betriebssystem gewählt, um eine bessere Wartbarkeit und Zuverlässigkeit aller eingesetzten Softwaredienste zu gewährleisten. Der Raspberry Pi ermöglicht somit eine zuverlässige Steuerung der Baustellencontainer.




\subsection{Proxmox [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{pics/proxmox_logo.png}
    \caption{Proxmox Virtual Environment Logo}
    \label{fig:proxmoxlogo}
\end{figure}

Proxmox Virtual Environment (Proxmox VE) ist eine Plattform zur Servervirtualisierung, die Open Source ist. 
Sie erlaubt den Betrieb mehrerer virtueller Systeme auf einer einzigen physischen Hardware und findet häufig Anwendung in Unternehmensumgebungen. 


Die Verwaltung wird zentral über eine webbasierte Benutzeroberfläche durchgeführt. 
Weitere Details finden Sie auf Proxmox offizieller Website (\url{https://www.proxmox.com}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{pics/proxmox_architecture.png}
    \caption{Architektur von Proxmox Virtual Environment}
    \label{fig:proxmoxarchitecture}
\end{figure}

Proxmox läuft auf einem Linux-Hostsystem und verwendet verschiedene Virtualisierungstechnologien. Proxmox fügt zwischen der Hardware und den Anwendungen eine Virtualisierungsschicht ein. Diese dient dazu, Systeme, die auf derselben Hardware laufen, voneinander zu trennen.

Virtuelle Maschinen (VMs) verhalten sich dabei jeweils wie ein eigener Computer mit einem eigenen Betriebssystem. Dadurch sind sie vollständig voneinander getrennt. CPU, Arbeitsspeicher und Speicherplatz werden im Vorhinein fest zugewiesen. Eine VM ist somit vollständig von anderen Systemen isoliert.

Zusätzlich unterstützt Proxmox Container auf Basis von Linux Containers (LXC). Container sind im Vergleich zu VMs leichter und schneller, da sie sich den Linux-Kernel des Servers teilen und arbeiten dadurch deutlich effizienter. Dadurch benötigen sie wenige Ressourcen und eignen sich sehr für den Betrieb Dienste oder Anwedungen.

Die Vorteile von Proxmox liegen unter anderem darin, dass keine Lizenzkosten anfallen, da Proxmox kostenlos verfügbar ist. Dadurch können die Betriebskosten eines Unternehmens gesenkt werden, insbesondere da Virtualisierungslösungen für virtuelle Maschinen zunehmend kostenintensiver werden. Zudem ermöglicht Proxmox eine effizientere Nutzung der vorhandenen Hardware, während die Systeme sauber voneinander getrennt bleiben. Durch das webbasierte Interface erhält der Benutzer eine gute Übersicht, da alle Systeme zentral verwaltet werden können.


\ref{fig:proxmoxarchitecture} dargestellt.



\section{Kommunikation und Automatisierung [Leopold Mistelberger]}
\subsection{Zigbee [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{MQTT [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}



\subsubsection{Beschreibung}
MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Nachrichtenprotokoll, das nach dem sogenannten \textit{Publish-Subscribe-Prinzip} arbeitet \cite{mqtt_org}. Dieses Protokoll wurde speziell für die Übertragung von Daten mit geringer Bandbreite oder instabiler Verbindung entwickelt. Es arbeitet ereignisbasiert und eignet sich besonders für Projekte, bei denen viele Geräte regelmäßig kleine Datenmengen wie Temperatur oder Luftfeuchtigkeit senden, wie beispielsweise in CESC.

\subsubsection{Komponenten und Funktionsweise}
Bei MQTT gibt es drei zentrale Komponenten, die nach dem Pub-Sub-Prinzip arbeiten:

\begin{itemize}
    \item \textbf{Publisher:} Ein Gerät oder Programm, das bestimmte Daten an den Broker sendet. In den meisten Fällen handelt es sich hierbei um einen Sensor.
    \item \textbf{Broker:} Meist ein zentraler Server, der alle Nachrichten empfängt und an die richtigen Empfänger weiterleitet.
    \item \textbf{Subscriber:} Ein Gerät oder Programm, das bestimmte Daten abonniert und diese empfängt.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/mqtt_pub_sub.png} 
    \caption{MQTT-Architektur: Publisher, Broker, Subscriber (Quelle: \url{https://mqtt.org/assets/img/mqtt-publish-subscribe.png}, Lizenz: CC0)}
    \label{fig:mqtt_architektur}
    
\end{figure}

Die Daten werden in sogenannten \textit{Topics} organisiert. Ein Publisher sendet Nachrichten an ein bestimmtes Topic, während Subscriber dieses Topic abonnieren. Der Broker übernimmt die Verteilung der Nachrichten, ohne dass sich Sender und Empfänger direkt kennen müssen.

\subsubsection{Beispielhafte Nutzung}
Um Daten zu empfangen, muss ein Subscriber ein bestimmtes Topic abonnieren. Beispielsweise möchte man die Raumtemperatur eines Containers auslesen. Dazu wird ein Subscriber auf das entsprechende Topic gesetzt:

\begin{lstlisting}[language=bash, caption={Subscriber für Raumtemperatur des Containers 147}]
mosquitto_sub -h <Broker-IP> -t "container/147/raum1/temperatur"
\end{lstlisting}

Neben dem Empfangen von Daten kann man auch Aktoren steuern, wie zum Beispiel die Heizung des Containers. Um diese einzuschalten, verwendet man den folgenden Publisher-Befehl:

\begin{lstlisting}[language=bash, caption={Heizung des Containers 147 einschalten}]
mosquitto_pub -h <Broker-IP> -t "container/147/raum1/heizung" -m "ON"
\end{lstlisting}





\subsubsection{Vorteile von MQTT}
MQTT bietet mehrere Vorteile gegenüber klassischen Kommunikationsprotokollen:

\begin{itemize}
    \item Geringer Netzwerk- und Ressourcenverbrauch
    \item Zuverlässige Datenübertragung auch bei instabilen Verbindungen
    \item Klare Trennung von Sendern und Empfängern
    \item Hohe Skalierbarkeit bei vielen beteiligten Geräten
    \item Besonders geeignet für IoT- und Sensornetzwerke
\end{itemize}


\subsection{Home Assistant [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\section{Container- und Laufzeitumgebung [Leopold Mistelberger]}
\subsection{Docker [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\subsection{GitHub Container Registry (ghcr.io) [Leopold Mistelberger]}
\setauthor{Leopold Mistelberger}

\section{Server- und Infrastrukturtechnologien [Elias Mahr]}
\setauthor{Elias Mahr}


\section{Reverse-Proxy [Elias Mahr]}
\setauthor{Elias Mahr}
Ein Reverse-Proxy steht zwischen dem Webserver und dem Internet. Im Grunde fungiert es wie ein Türsteher für den Server. Anfragen werden von außen entgegengenommen und zum richtigen Dienst weitergeleitet(Frontend, Backend, Keycloak,...). Dadurch werden die echten Adressen verschleiert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{pics/ReverseProxy.png}
    \caption{Reverse-Proxy (Quelle: \url{https://commons.wikimedia.org/wiki/File:Reverse_proxy_h2g2bob.svg}, Lizenz: CC0)}
    \label{fig:ReverseProxy}
\end{figure}

\subsection{Nutzen in der Diplomarbeit}
Es gibt drei Hauptgründe, weshalb ein Reverse-Proxy eingebaut werden musste.
\begin{itemize}
\item \underline{Keycloaks https Redirects:}
Keycloak verwendet moderne Standards wie OpenID Connect. Diese Standards setzen auch eine HTTPs Redirect URL voraus. Https setzt im Gegensatz zu http die nötigen Sicherheitsstandards, um zum Beispiel Man-in-the-Middle-Angriffe zu verhindern.
\item \underline{Port Chaos:}
Mit vielen verschiedenen Ports, wie 80 für das Frontend, 8080 für Keycloak und 5000 für das Backend wäre alles sehr unübersichtlich. Der User müsste sich 3 URLs merken.
\item \underline{Sicherheit:}
Zur Reduzierung der Angriffsfläche sollten nur zwingend notwendige Ports öffentlich erreichbar sein. Jeder zusätzlich exponierte Dienst erhöht das Risiko potenzieller Angriffe.
Interne Dienste, wie beispielsweise Backend-Services auf Port 5000, sind nicht von außen erreichbar und bleiben dadurch vor direktem Zugriff geschützt. Die Trennung zwischen öffentlich zugänglichen Komponenten und internen Services stellt eine grundlegende Sicherheitsmaßnahme dar.
Auch wenn eine Webapplikation ausschließlich innerhalb des Intranets betrieben wird, ist der Einsatz zusätzlicher Sicherheitsmechanismen sinnvoll. Eine mehrschichtige Sicherheitsstrategie (Defense in Depth) trägt dazu bei, das Gesamtrisiko weiter zu reduzieren.
\end{itemize}


\section{Auswahl der Technologie - Sicherheit(Authentifizierung)}
\setauthor{Elias Mahr}

\subsection{Selbsterstellter Login Mechanismus}
Eine nicht sichere aber durchaus mögliche Option wäre eine selbstgeschriebene Login Componente die Passwort und Nutzer Gehasht in der Datenbank speichert. 
\subsubsection{Vorteile}
Diese Option hätte den Vorteil einerseits sehr geringe Ressourcen zu beanspruchen. Die Componente könnte man auch direkt ins Backend integrieren, dies wäre in unserem Fall für nur einen Nutzer nicht sehr Zeitaufwändig. Alles könnte direkt nach den Wunsch der Firma gebaut werden.
\subsubsection{Nachteile}
Die Sicherheit bei einer Selbsterstellten Componente ist für Firmen nicht ausreichend. Herbsthofer Liegt sehr viel wert auf Sicherheit und dafür ist eine selbst erstellte Componente möglicherweise nicht geeignet.
Für erfahrene Hacker könnte so ein Login ein leichtes sein um als Admin auf die Webseite zu kommen mit zum Beispiel einem Brute Force Angriff. Auch von Nachteil ist, dass sollte die Webapp von der Firma in Zukunft erweitert werden ist dies sehr schwierig und muss von einem externen Programmierer gemacht werden.

\subsection{Vorgefertigter Login (Keycloak [Elias Mahr])}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{pics/KeycloakLogo.png}
    \caption{Keycloak Logo}
    \label{fig:KeycloakLogo}
\end{figure}
Keycloak ist ein Open Source System, das die sichere Anmeldung und die Rechteverwaltung für unsere Anwendungen übernimmt. Die Anwendungen schicken die Anmeldung an Keycloak und müssen das Speichern und das Prüfen von Benutzerkonten nicht mehr selbst erledigen. So kann die Anwendung sich auf das Wesentliche konzentrieren, während Keycloak die Anmeldung und die Rechte im Hintergrund mit Sicherheitsstandards für Unternehmen regelt.

\subsubsection{Grundidee und Zweck}
Die Firma Herbsthofer legt sehr großen Wert auf Sicherheit. Die externe Bedienung von Heizung, Kühlung und Beleuchtung kann, bei unsachgemäßer Nutzung, zu erheblichen Mehrkosten und mitunter auch zu Schäden führen.

\begin{itemize}
\item Mitarbeiterschutz:
Bei voll eingeschalteter Kühlung an kalten Wintertagen kann es zu gesundheitlichen Schäden in Form von Verkühlungen bei Arbeitern/Arbeiterinnen führen, die auch mit einem Ausfall für ein paar Tage enden können und so der Firma Geld kosten.
\item Brandgefahr:
Nicht zu vergessen ist auch die erhöhte Brandgefahr. Unkontrollierte Heizbetriebe auf einer zu hohen Temperaturstufe kann im schlimmsten Fall zu Bränden führen und so erheblichen Schaden anrichten und Personenschaden mit sich führen.
\item Kosten: 
Strom wird immer teurer. Bei durchgehender Nutzung auch an Tagen, an denen niemand im Container ist, ist erstens der Schaden an der Umwelt durch extreme Ressourcen Verschwendung zu beachten. Zudem entstehen für das Unternehmen hohe, vermeidbare Stromkosten.
\end{itemize}

\section{Cronjob}
\setauthor{Elias Mahr}

Um die Container wirklich voll automatisch ein und ausschalten zu können, kam für uns nur die Verwendung eines Cronjob auf dem Server in Frage. Im Unterricht hatten wir bereits davon gehört.
Ein Cron-Daemon ist ein Linux-Programm das meistens Shell Skripte Zeitgesteuert auslöst, sogenannte Cronjobs. 
Somit kann man Aufgaben nach einem Zeitplan immer wiederholend ausführen.

\subsection{Syntax}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{pics/Cronjob.png}
    \caption{Cronjob Syntax}
    \label{fig:CronjobSyntax}
\end{figure}

Jeder Cronjob ist eine Zeile in dem crontab File. Diese Zeile definiert mit der oben gezeigten Syntax wann und wie oft welches Skript ausgeführt werden soll.
So können komplizierte Zeit Schaltungen auch gebaut werden. Mit / können Schritte definiert werden wie zum Beispiel bei Stunde = /6 würde heißen jede sechste Stunde. Auch gib es einen Operator mit dem man Bereiche definieren kann: -. 


\section{Angular}
\setauthor{Elias Mahr}

\section{Api}
\setauthor{Elias Mahr}